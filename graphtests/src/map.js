// Generated by CoffeeScript 1.3.3
(function() {
  var Instance, Map, Obstacle, Route, Town,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Town = (function(_super) {

    __extends(Town, _super);

    Town.prototype.type = 'Town';

    function Town(x, y) {
      this.x = x;
      this.y = y;
      Town.__super__.constructor.call(this);
    }

    return Town;

  })(Node);

  Route = (function(_super) {

    __extends(Route, _super);

    Route.prototype.type = 'Route';

    function Route(x, y) {
      this.x = x;
      this.y = y;
      Route.__super__.constructor.call(this);
    }

    return Route;

  })(Node);

  Instance = (function(_super) {

    __extends(Instance, _super);

    Instance.prototype.type = 'Instance';

    function Instance(x, y) {
      this.x = x;
      this.y = y;
      Instance.__super__.constructor.call(this);
    }

    return Instance;

  })(Node);

  Obstacle = (function(_super) {

    __extends(Obstacle, _super);

    Obstacle.prototype.type = 'Obstacle';

    function Obstacle(x, y) {
      this.x = x;
      this.y = y;
      Obstacle.__super__.constructor.call(this);
    }

    return Obstacle;

  })(Node);

  Map = (function() {

    function Map(opts) {
      this.graph = new Graph();
      this.active = [];
      this.graph.add(new Town(0, 0));
      this.active.push(this.graph.nodes[0]);
    }

    Map.prototype.distance = function(n1, n2) {
      return Math.sqrt(Math.pow(n1.x - n2.x, 2) + Math.pow(n1.y - n2.y, 2));
    };

    Map.prototype.clearance = function(node, threshold) {
      var node2, _i, _len, _ref;
      _ref = this.graph.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node2 = _ref[_i];
        if (this.distance(node, node2) < threshold) {
          return false;
        }
        if (node2.type === 'Obstacle' && this.distance(node, node2) < threshold * 3) {
          return false;
        }
      }
      return true;
    };

    Map.prototype.edgeCheck = function(node) {
      var max;
      max = {
        Town: 4,
        Route: 4,
        Instance: 2,
        Obstacle: 0
      }[node.type];
      return node.edges.length < max;
    };

    Map.prototype.cull = function() {
      var node, node2, orphan, toCull, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;
      toCull = [];
      _ref = this.graph.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (node.type === 'Route') {
          if (node.edges.length < 2) {
            toCull.push(node);
          } else {
            orphan = true;
            _ref1 = node.adj();
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              node2 = _ref1[_j];
              if (node2.type !== 'Route') {
                orphan = false;
              }
            }
          }
        }
      }
      console.log('culling', toCull.length, toCull);
      _results = [];
      for (_k = 0, _len2 = toCull.length; _k < _len2; _k++) {
        node = toCull[_k];
        _results.push(this.graph.remove(node));
      }
      return _results;
    };

    Map.prototype.genObs = function() {
      var d, node, x, y;
      x = (Math.random() - 0.5) * window.innerWidth;
      y = (Math.random() - 0.5) * window.innerHeight;
      if (!((-(window.innerWidth / 2 - 30) < x && x < (window.innerWidth / 2 - 30)))) {
        return false;
      }
      if (!((-(window.innerHeight / 2 - 30) < y && y < (window.innerHeight / 2 - 30)))) {
        return false;
      }
      d = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
      if (!(d > 100)) {
        return false;
      }
      node = new Obstacle(x, y);
      this.graph.add(node);
      return this.active.push(node);
    };

    Map.prototype.gen1 = function() {
      var dir, dist, node, node2, src, tries, x, y, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      if (this.active.length === 0) {
        _ref = this.graph.nodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          if (!this.edgeCheck(node)) {
            continue;
          }
          this.active.push(node);
          node.tries = 0;
        }
      }
      src = null;
      tries = 2000;
      while (tries > 0 && !(src != null)) {
        tries--;
        node = this.active[Math.floor(Math.random() * this.active.length)];
        if (!node) {
          continue;
        }
        if (node.tries == null) {
          node.tries = 0;
        }
        if (node.tries > 50) {
          this.active.splice(this.active.indexOf(node), 1);
          return;
        }
        if (this.edgeCheck(node)) {
          src = node;
        } else {
          node.tries = 50;
          this.active.splice(this.active.indexOf(node), 1);
        }
      }
      if (!src) {
        return false;
      }
      dist = 15;
      x = src.x + (Math.random() - 0.5) * dist;
      y = src.y + (Math.random() - 0.5) * dist;
      dir = Math.random() * Math.PI * 2;
      x = src.x + dist * Math.sin(dir);
      y = src.y + dist * Math.cos(dir);
      src.tries = src.tries + 1;
      if (!((-(1512 - 30) < x && x < (1512 - 30)))) {
        return false;
      }
      if (!((-(1256 - 30) < y && y < (1256 - 30)))) {
        return false;
      }
      if (!((-(window.innerWidth / 2 - 30) < x && x < (window.innerWidth / 2 - 30)))) {
        return false;
      }
      if (!((-(window.innerHeight / 2 - 30) < y && y < (window.innerHeight / 2 - 30)))) {
        return false;
      }
      if (!this.edgeCheck(src)) {
        return false;
      }
      if (!this.clearance({
        x: x,
        y: y
      }, 15)) {
        return false;
      }
      src.tries = src.tries - 1;
      if (src.type === 'Town') {
        if (Math.random() < 0.1) {
          node = new Instance(x, y);
        } else if (Math.random() < 0.1) {
          node = new Town(x, y);
        } else {
          node = new Route(x, y);
        }
      } else if (src.type === 'Instance') {
        if (Math.random() < 0.6) {
          node = new Instance(x, y);
        } else {
          node = new Route(x, y);
        }
      } else {
        if (Math.random() < 10.7) {
          node = new Route(x, y);
        } else {
          node = new Town(x, y);
        }
      }
      this.graph.add(node);
      this.active.push(node);
      this.graph.link(src, node);
      _ref1 = this.graph.nodes;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        node2 = _ref1[_j];
        if (node2 !== node && node2 !== src && (10 < (_ref2 = this.distance(node, node2)) && _ref2 < 20) && (node.type === 'Route' || (true && node.type !== node2.type)) && this.edgeCheck(node) && this.edgeCheck(node2)) {
          this.graph.link(node, node2);
        }
      }
      return true;
    };

    return Map;

  })();

  window.Map = Map;

  window.Town = Town;

  window.Route = Route;

}).call(this);
