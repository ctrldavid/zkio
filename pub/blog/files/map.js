// Generated by CoffeeScript 1.3.1
(function() {
  var ASPECT, FAR, HEIGHT, NEAR, Point, PointSpread, VIEW_ANGLE, WIDTH, ambientLight, bbox, camera, cell, cx, cy, directionalLight, draw, edge, fgeometry, floor, fmat, fobject, fvert0, fvert1, fvert2, fvert3, geometry, halfedge, height, index, mat, material, object, pointLight, pointLightx, points, r, renderer, result, scene, t, vert0, vert1, vert2, vert3, voronoi, width, x, z, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4;

  Point = (function() {

    Point.name = 'Point';

    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    return Point;

  })();

  PointSpread = (function() {

    PointSpread.name = 'PointSpread';

    function PointSpread(width, height, spacing) {
      this.width = width;
      this.height = height;
      this.spacing = spacing;
      this.points = [];
      this.points.push(new Point(this.width / 2, this.height / 2));
      this.generate();
    }

    PointSpread.prototype.rw = function() {
      return Math.random() * this.width;
    };

    PointSpread.prototype.rh = function() {
      return Math.random() * this.height;
    };

    PointSpread.prototype.dist = function(a, b) {
      return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
    };

    PointSpread.prototype.generate = function() {
      var attempts, dist, fail, fails, newPoint, point, _i, _len, _ref, _results;
      attempts = 0;
      fails = 0;
      _results = [];
      while (attempts < 1000 || fails / attempts < 0.99) {
        newPoint = new Point(this.rw(), this.rh());
        fail = false;
        _ref = this.points;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          point = _ref[_i];
          dist = this.dist(point, newPoint);
          if (dist < this.spacing) {
            fail = true;
          }
        }
        if (!fail) {
          this.points.push(newPoint);
        }
        attempts++;
        if (fail) {
          _results.push(fails++);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return PointSpread;

  })();

  width = 600;

  height = 600;

  floor = -10;

  draw = function(ctx) {
    var bbox, cell, edge, halfedge, points, result, voronoi, x, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
    x = new PointSpread(width, height, 35);
    console.log(x.points);
    points = x.points;
    bbox = {
      xl: 0,
      xr: width,
      yt: 0,
      yb: height
    };
    voronoi = new Voronoi();
    result = voronoi.compute(points, bbox);
    _ref = result.cells;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cell = _ref[_i];
      ctx.fillStyle = "rgba(64,64,64,1.0)";
      ctx.beginPath();
      ctx.moveTo(cell.halfedges[0].getStartpoint().x, cell.halfedges[0].getStartpoint().y);
      _ref1 = cell.halfedges;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        halfedge = _ref1[_j];
        ctx.lineTo(halfedge.getEndpoint().x, halfedge.getEndpoint().y);
      }
      ctx.closePath();
      ctx.fill();
    }
    ctx.strokeStyle = "rgba(127,127,127,1.0)";
    _ref2 = result.edges;
    _results = [];
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      edge = _ref2[_k];
      ctx.beginPath();
      ctx.moveTo(edge.va.x, edge.va.y);
      ctx.lineTo(edge.vb.x, edge.vb.y);
      _results.push(ctx.stroke());
    }
    return _results;
  };

  WIDTH = 500;

  HEIGHT = 300;

  VIEW_ANGLE = 45;

  ASPECT = WIDTH / HEIGHT;

  NEAR = 0.1;

  FAR = 10000;

  renderer = new THREE.WebGLRenderer();

  camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);

  scene = new THREE.Scene();

  scene.add(camera);

  camera.position.set(WIDTH / 2, HEIGHT / 2, 100);

  camera.lookAt(new THREE.Vector3(WIDTH / 2, HEIGHT / 2, 0));

  renderer.setSize(WIDTH, HEIGHT);

  document.getElementById('map').appendChild(renderer.domElement);

  material = new THREE.LineBasicMaterial({
    color: 0x4488ff
  });

  x = new PointSpread(width, height, 35);

  console.log(x.points);

  points = x.points;

  bbox = {
    xl: 0,
    xr: width,
    yt: 0,
    yb: height
  };

  voronoi = new Voronoi();

  result = voronoi.compute(points, bbox);

  console.log(result);

  _ref = result.cells;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    cell = _ref[_i];
    cell.isBorder = false;
    _ref1 = cell.halfedges;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      halfedge = _ref1[_j];
      if (!((halfedge.edge.lSite != null) && (halfedge.edge.rSite != null))) {
        cell.isBorder = true;
      }
    }
    if (Math.random() < 0.3) {
      cell.isBorder = true;
    }
    cell.height = Math.floor(Math.random() * 5) * 10;
    if (cell.isBorder) {
      cell.height = floor;
    }
    cell.site.height = cell.height;
  }

  _ref2 = result.cells;
  for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
    cell = _ref2[_k];
    if (cell.isBorder) {
      continue;
    }
    if (Math.random() < 0.00) {
      pointLightx = new THREE.PointLight(0xff0000);
      pointLightx.position.x = cell.site.x;
      pointLightx.position.y = cell.height + 5;
      pointLightx.position.z = cell.site.y;
      scene.add(pointLightx);
    }
    geometry = new THREE.Geometry();
    vert0 = new THREE.Vector3(cell.halfedges[0].getEndpoint().x, cell.height, cell.halfedges[0].getEndpoint().y);
    vert1 = new THREE.Vector3(cell.halfedges[1].getEndpoint().x, cell.height, cell.halfedges[1].getEndpoint().y);
    geometry.vertices.push(vert0);
    geometry.vertices.push(vert1);
    _ref3 = cell.halfedges;
    for (index = _l = 0, _len3 = _ref3.length; _l < _len3; index = ++_l) {
      halfedge = _ref3[index];
      if (index < 2) {
        continue;
      }
      vert2 = new THREE.Vector3(cell.halfedges[index].getEndpoint().x, cell.height, cell.halfedges[index].getEndpoint().y);
      geometry.vertices.push(vert2);
      geometry.faces.push(new THREE.Face3(0, index - 1, index));
      vert1 = vert2;
    }
    geometry.computeFaceNormals();
    if (Math.random() < 0.0001) {
      mat = new THREE.MeshPhongMaterial({
        color: 0x00ff00
      });
    } else {
      mat = new THREE.MeshPhongMaterial({
        color: 0x886622
      });
    }
    object = new THREE.Mesh(geometry, mat);
    scene.add(object);
    cell.site.isBorder = cell.isBorder;
  }

  _ref4 = result.edges;
  for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
    edge = _ref4[_m];
    if (!(edge.rSite != null) || edge.rSite.isBorder) {
      continue;
    }
    if (!(edge.lSite != null) || edge.lSite.isBorder) {
      continue;
    }
    vert0 = new THREE.Vector3(edge.va.x, edge.rSite.height, edge.va.y);
    vert1 = new THREE.Vector3(edge.vb.x, edge.rSite.height, edge.vb.y);
    vert3 = new THREE.Vector3(edge.va.x, edge.lSite.height, edge.va.y);
    vert2 = new THREE.Vector3(edge.vb.x, edge.lSite.height, edge.vb.y);
    geometry = new THREE.Geometry();
    geometry.vertices.push(vert0);
    geometry.vertices.push(vert1);
    geometry.vertices.push(vert2);
    geometry.vertices.push(vert3);
    geometry.faces.push(new THREE.Face4(0, 1, 2, 3));
    geometry.computeFaceNormals();
    mat = new THREE.MeshPhongMaterial({
      color: 0x886622
    });
    object = new THREE.Mesh(geometry, mat);
    scene.add(object);
  }

  fvert0 = new THREE.Vector3(0, floor, 0);

  fvert3 = new THREE.Vector3(width, floor, 0);

  fvert2 = new THREE.Vector3(width, floor, height);

  fvert1 = new THREE.Vector3(0, floor, height);

  fgeometry = new THREE.Geometry();

  fgeometry.vertices.push(fvert0);

  fgeometry.vertices.push(fvert1);

  fgeometry.vertices.push(fvert2);

  fgeometry.vertices.push(fvert3);

  fgeometry.faces.push(new THREE.Face4(0, 1, 2, 3));

  fgeometry.computeFaceNormals();

  fmat = new THREE.MeshPhongMaterial({
    color: 0x002288
  });

  fobject = new THREE.Mesh(fgeometry, fmat);

  scene.add(fobject);

  console.log('fob', fobject);

  pointLight = new THREE.PointLight(0xEEDDFF);

  pointLight.position.x = WIDTH / 2;

  pointLight.position.y = 100;

  pointLight.position.z = HEIGHT / 2;

  scene.add(pointLight);

  directionalLight = new THREE.DirectionalLight(0x111111);

  directionalLight.position.set(1, 10, 1).normalize();

  scene.add(directionalLight);

  ambientLight = new THREE.AmbientLight(0x111111);

  scene.add(ambientLight);

  cx = width / 2;

  cy = height / 2;

  r = 600;

  z = 500;

  t = 0;

  window.setInterval(function() {
    var y;
    t = t + 0.001;
    x = cx + r * Math.sin(t);
    y = cy + r * Math.cos(t);
    pointLight.position.set(cx + 300 * Math.sin(50 * t), 100, cx + 300 * Math.cos(40 * t));
    camera.position.set(x, z, y);
    camera.lookAt(new THREE.Vector3(width / 2, 0, height / 2));
    return renderer.render(scene, camera);
  }, 10);

  /*
     o
    / \
   /   \
  o     o
   \   /
    o-o
  */


}).call(this);
